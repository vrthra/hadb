#!/bin/bash
_check_wal() {
  ps -eaf | grep sender
  echo "WAL status in server"
  psql -c "SELECT pg_xlog_location_diff(pg_current_xlog_location(), '0/0') AS offset;"
}
_check_sql() {
  [ -e .fake_customers ] || ( psql -c "CREATE TABLE fake_customers (name VARCHAR(32));" && touch .fake_customers )
  psql -c "INSERT INTO fake_customers values ('$(date)');"
}
_to_standby() {
  echo "Going to become standby."
  sudo service pe-postgresql stop
  rm -rf /opt/puppet/var/lib/pgsql/9.2/wal_archive; mkdir -p /opt/puppet/var/lib/pgsql/9.2/wal_archive
  echo "Register ourselves."
  cat slaves.info | sed -e 's#/32##g' > .masterip
  ssh $(<.masterip) 'echo $(cat .masterip)/32 > slaves.info'
  echo "> Wal Archiving would not be enabled in the server if it was a standby failover."
  ssh $(<.masterip) 'sudo service pe-postgresql restart'
  ssh $(<.masterip) './bin/pg.backup $(<.masterip)'
  # creating the recovery.conf.
  ./bin/recovery.conf.sh
  sudo service pe-postgresql start
  psql -c "select pg_last_xlog_receive_location()"
}
_back_to_master() {
  # First we need this to be in standby mode. This is accomplished by
  _to_standby
  echo "Going to become master."
  # Then flip the switch
  touch .trigger
  sleep 5
  psql -c "INSERT INTO fake_customers values ('$(date)');" && echo "it worked."
}
_log() {
   tail -f /opt/puppet/var/lib/pgsql/9.2/data/pg_log/*.log
}
export PS1='master| '
